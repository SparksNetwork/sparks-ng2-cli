// Generated by typings
// Source: https://raw.githubusercontent.com/typed-contrib/docker-modem/17ef3221e18bbf718c422897d63a17295f13e537/lib/modem.d.ts
declare module '~dockerode~docker-modem' {
// Type definitions for docker-modem v0.3.1
// Project: https://github.com/apocas/docker-modem
// Definitions by: Maxime LUCE <https://github.com/SomaticIT/>
// Definitions: https://github.com/typed-contrib/docker-modem

class Modem implements Modem.SocketOptions, Modem.HostOptions {
    public socketPath?: string;
    public protocol?: string;
    public host: string;
    public port: number;
    public ca?: Buffer;
    public cert?: Buffer;
    public key?: Buffer;
    public version?: string | number;
    public timeout?: number;
    public checkServerIdentity?: boolean;

    /**
     * Constructs a new Modem.
     * 
     * @param [opts]        Authentication options.
     *                      If not provided, it will look for Environment variables.
     *                      If no Environment variable is found, it is set to `/var/run/docker.sock`.
     */
    constructor(opts?: Modem.SocketOptions | Modem.HostOptions);

    /**
     * Dial `Docker` Remote API.
     * 
     * @param options       Modem dial options.
     * @param callback      Callback which will be called with Remote API result. 
     */
    public dial<T>(options: Modem.DialOptions, callback: Modem.Callback<T>): void;

    /**
     * Demultiplex attach streams to separate `stdout` from `stderr`.
     * 
     * @param stream        Input stream to demultiplex.
     * @param stdout        Output stream from `stdout`.
     * @param stderr        Output stream from `stderr`.
     */
    public demuxStream(stream: NodeJS.ReadableStream, stdout: NodeJS.WritableStream, stderr: NodeJS.WritableStream): void;

    /**
     * Allows to fire a callback only in the end of a stream based process. (build, pull, ...)
     * 
     * @param stream        Input stream to follow.
     * @param onFinished    Callback which will be called when stream ends.
     * @param [onProgress]  Callback which will be called multiple times to report job progress.
     */
    public followProgress<T>(stream: NodeJS.ReadableStream, onFinished: Modem.Callback<T>, onProgress?: (evt: any) => void);

    /**
     * Builds Query String parameters from Object.
     * 
     * @param opts          Object representing Query String.
     */
    public buildQuerystring(opts: Object): string;

    private buildRequest<T>(options: any, context: Modem.DialOptions, data: string | Buffer, callback: Modem.Callback<T>): void;
    private buildPayload<T>(err: Error, isStream: boolean, statusCodes: Object, openStdin: boolean, req: any, res: any, json: any, cb: Modem.Callback<T>): void;
}

namespace Modem {
    export interface SocketOptions {
        socketPath?: string;
        version?: string | number;
        timeout?: number;
    }

    export interface HostOptions {
        protocol?: string;
        host: string;
        port: number;
        ca?: Buffer;
        cert?: Buffer;
        key?: Buffer;
        version?: string | number;
        timeout?: number;
        checkServerIdentity?: boolean;
    }

    export interface DialOptions {
        path: string;
        method: string;
        headers?: Object;
        authconfig?: AuthConfig;
        registryconfig?: RegistryConfig;
        file?: string | Buffer;
        hijack?: boolean;
    }

    export type AuthConfig = { key: string; } | { base64: string; } | Auth | Identity;
    export type RegistryConfig = { base64: string; } | Object;
        
    export interface Auth {
        username: string;
        password: string;
        email: string;
    }

    export interface Identity {
        identitytoken: string;
    }

    export type Callback<T> = (err: Error, data: T) => void;
}

export = Modem;
}

// Generated by typings
// Source: https://raw.githubusercontent.com/typed-contrib/dockerode/b88ec97d60fe98523e15e0fcc0e578030fdddcf4/lib/container.d.ts
declare module '~dockerode/lib/container' {
// Type definitions for dockerode v2.3.1
// Project: https://github.com/apocas/dockerode
// Definitions by: Maxime LUCE <https://github.com/SomaticIT/>
// Definitions: https://github.com/typed-contrib/dockerode

import * as Modem from '~dockerode~docker-modem';
import { Readable, Duplex } from 'stream';

import * as Exec from '~dockerode/lib/exec';
import { Boolean, Callback, Dictionary } from '~dockerode/lib/util';

/** Represents a Container. */
class Container {
    public modem: Modem;
    public id: string;
    public defaultOptions: {
        top: Container.TopOptions;
        start: Container.StartOptions;
        commit: Container.CommitOptions;
        stop: Container.StopOptions;
        restart: Container.RestartOptions;
        resize: Container.ResizeOptions;
        attach: Container.AttachOptions;
        remove: Container.RemoveOptions;
        copy: Container.CopyOptions;
        kill: Container.KillOptions;
        exec: Container.ExecOptions;
        rename: Container.RenameOptions;
        log: Container.LogsOptions;
        stats: Container.StatsOptions;
        getArchive: Container.ArchiveOptions;
        infoArchive: Container.ArchiveOptions;
        putArchive: Container.ArchiveOptions;
        update: Container.UpdateOptions;
    };

    /**
     * Constructs a new Container instance.
     * 
     * @param modem     docker-modem.
     * @param id        Container's ID or name.
     */
    constructor(modem: Modem, id: string);

    /**
     * Does not query Docker.
     * Only return {"id":"someid"} as String.
     */
    public inspect(): string;

    /**
     * Return low-level information for this Docker container.
     * 
     * @param callback  Callback which will be called when call ends.
     */
    public inspect(callback: Callback<Container.ContainerResult>): void;
    /**
     * Return low-level information for this Docker container.
     * 
     * @param opts      Options for inspection.
     * @param callback  Callback which will be called when call ends.
     */
    public inspect(opts: Container.InspectOptions, callback: Callback<Container.ContainerResult>): void;

    /**
     * Rename this container.
     * 
     * @param opts      Options for renaming.
     * @param callback  Callback which will be called when call ends.
     */
    public rename(opts: Container.RenameOptions, callback: Callback<void>): void;

    /**
     * Update this container.
     * 
     * @param opts      Update options.
     * @param callback  Callback which will be called when call ends.
     */
    public update(opts: Container.UpdateOptions, callback: Callback<Container.UpdateResult>): void;

    /**
     * List processes running inside this container.
     * On Unix systems this is done by running the `ps` command.
     * This endpoint is not supported on Windows.
     * 
     * @param callback  Callback which will be called when call ends.
     */
    public top(callback: Callback<Container.TopResult>): void;
    /**
     * List processes running inside this container.
     * On Unix systems this is done by running the `ps` command.
     * This endpoint is not supported on Windows.
     * 
     * @param opts      Options (like `ps_args`).
     * @param callback  Callback which will be called when call ends.
     */
    public top(opts: Container.TopOptions, callback: Callback<Container.TopResult>): void;

    /**
     * Inspect changes on this container's filesystem
     * 
     * @param callback  Callback which will be called when call ends.
     */
    public changes(callback: Callback<Container.ChangesResult[]>): void;

    /**
     * Export the content of this container to a `tar` archive.
     * 
     * @param callback  Callback with the octet-stream.
     */
    public export(callback: Callback<Readable>): void;

    /**
     * Start this container.
     * 
     * @param callback  Callback which will be called when call ends.
     */
    public start(callback: Callback<void>): void;
    /**
     * Start this container.
     * 
     * @param opts      Container start options.
     * @param callback  Callback which will be called when call ends.
     */
    public start(opts: Container.StartOptions, callback: Callback<void>): void;

    /**
     * Pause this container.
     * 
     * @param callback  Callback which will be called when call ends.
     */
    public pause(callback: Callback<void>): void;

    /**
     * Resume this container.
     * 
     * @param callback  Callback which will be called when call ends.
     */
    public unpause(callback: Callback<void>): void;

    /**
     * Set up an `exec` call to this running container.
     * 
     * @param opts      Container exec options.
     * @param callback  Callback which will be called when call ends.
     */
    public exec(opts: Container.ExecOptions, callback: Callback<Exec>): void;

    /**
     * Commit container changes.
     * 
     * @param callback  Callback which will be called when call ends.
     */
    public commit(callback: Callback<Container.CommitResult>): void;
    /**
     * Commit container changes.
     * 
     * @param opts      Container commit options (like `Hostname`).
     * @param callback  Callback which will be called when call ends.
     */
    public commit(opts: Container.CommitOptions, callback: Callback<Container.CommitResult>): void;

    /**
     * Stop this container.
     * 
     * @param callback  Callback which will be called when call ends.
     */
    public stop(callback: Callback<void>): void;
    /**
     * Stop this container.
     * 
     * @param opts      Container stop options (like `t`).
     * @param callback  Callback which will be called when call ends.
     */
    public stop(opts: Container.StopOptions, callback: Callback<void>): void;

    /**
     * Restart this container.
     * 
     * @param callback  Callback which will be called when call ends.
     */
    public restart(callback: Callback<void>): void;
    /**
     * Restart this container.
     * 
     * @param opts      Container restart options (like `t`).
     * @param callback  Callback which will be called when call ends.
     */
    public restart(opts: Container.RestartOptions, callback: Callback<void>): void;

    /**
     * Kill this container.
     * 
     * @param callback  Callback which will be called when call ends.
     */
    public kill(callback: Callback<void>): void;
    /**
     * Kill this container.
     * 
     * @param opts      Container kill options (like `signal`).
     * @param callback  Callback which will be called when call ends.
     */
    public kill(opts: Container.KillOptions, callback: Callback<void>): void;

    /**
     * Resize the TTY for this container.
     * The unit is number of characters.
     * You must restart the container for the resize to take effect.
     * 
     * @param opts      Container resize options.
     * @param callback  Callback which will be called when call ends.
     */
    public resize(opts: Container.ResizeOptions, callback: Callback<void>): void;

    /**
     * Attach to this container output (and optionnally input).
     * 
     * @param callback  Callback with stream.
     */
    public attach(callback: Callback<Duplex>): void;
    /**
     * Attach to this container output (and optionnally input).
     * 
     * @param opts      Container attach options.
     * @param callback  Callback with stream.
     */
    public attach(opts: Container.AttachOptions, callback: Callback<Duplex>): void;
    
    /**
     * Wait until this container's stop, then returns the exit code.
     * 
     * @param callback  Callback which will be called when call ends.
     */
    public wait(callback: Callback<Container.WaitResult>): void;

    /**
     * Remove this container from the filesystem.
     * 
     * @param callback  Callback which will be called when call ends.
     */
    public remove(callback: Callback<void>): void;
    /**
     * Remove this container from the filesystem.
     * 
     * @param opts      Container remove options (like `force`).
     * @param callback  Callback which will be called when call ends.
     */
    public remove(opts: Container.RemoveOptions, callback: Callback<void>): void;
    
    /**
     * Copy this container (WARNING! DEPRECATED SINCE REMOTE API 1.20).
     * 
     * @deprecated
     * @param callback  Callback with stream.
     */
    public copy(callback: Callback<Readable>): void;
    /**
     * Copy this container (WARNING! DEPRECATED SINCE REMOTE API 1.20).
     * 
     * @deprecated
     * @param opts      Container copy options (like `Resource`).
     * @param callback  Callback with stream.
     */
    public copy(opts: Container.CopyOptions, callback: Callback<Readable>): void;
    
    /**
     * Get an archive of a filesystem resource in this container.
     * 
     * @param opts      Archive options (like `path`).
     * @param callback  Callback with stream.
     */
    public getArchive(opts: Container.ArchiveOptions, callback: Callback<Readable>): void;
    
    /**
     * Retrieves information about files and folders in this container.
     * 
     * @param opts      Archive options (like `path`).
     * @param callback  Callback with stream.
     */
    public infoArchive(opts: Container.ArchiveOptions, callback: Callback<Container.ArchiveInformations>): void;
    
    /**
     * Put container archive.
     * 
     * @param file      Archive file to put.
     * @param opts      Archive options (like `path`).
     * @param callback  Callback with stream.
     */
    public putArchive(file: string, opts: Container.PutArchiveOptions, callback: Callback<Readable>): void;
    
    /**
     * Get `stdout` and `stderr` logs from the container `id`.
     * 
     * @param callback  Callback with stream.
     */
    public logs(callback: Callback<Readable>): void;
    /**
     * Get `stdout` and `stderr` logs from the container `id`.
     * 
     * @param opts      Container logs options.
     * @param callback  Callback with stream.
     */
    public logs(opts: Container.LogsOptions, callback: Callback<Readable>): void;
    
    /**
     * Get this container's stats.
     * 
     * @param callback  Callback with stream.
     */
    public stats(callback: Callback<Readable>): void;
    /**
     * Get this container's resource usage statistics (as a live stream).
     * 
     * @param opts      Container stats options.
     * @param callback  Callback with stream.
     */
    public stats(opts: Container.StatsOptions, callback: Callback<Readable>): void;
    /**
     * Get this container's resource usage statistics (not as stream).
     * 
     * @param opts      Container stats options.
     * @param callback  Callback with stream.
     */
    public stats(opts: {stream: 0|false} & Container.StatsOptions, callback: Callback<Container.StatsResult>): void;
}

namespace Container {
    export interface InspectOptions {
        /** `true` or `1` to return container size information. Default is `false` */
        size?: Boolean;
    }

    export interface ContainerResult {
        Id: string;
        Image: string;
        Name: string;

        AppArmorProfile: string;
        Args: string[];
        Config: ContainerConfig;
        Created: string;
        Driver: string;
        ExecIDs: string[];
        HostConfig: HostConfig;
        HostnamePath: string;
        HostsPath: string;
        LogPath: string;
        MountLabel: string;
        NetworkSettings: NetworkSettings;
        Path: string;
        ProcessLabel: string;
        ResolvConfPath: string;
        RestartCount: number;
        State: ContainerState;
        Mounts: ContainerMount[];
        SizeRw?: number;
        SizeRootFs?: number;
    }

    export interface ContainerListItem {
        Id: string;
        Names: string[];
        Image: string;
        ImageID: string;
        Command: string;
        Created: number;
        State: string;
        Status: string;
        Ports: Port[];
        Labels: Dictionary<string>;
        SizeRw: number;
        SizeRootFs: number;
        HostConfig: HostConfig;
        NetworkSettings: NetworkSettings;
        Mounts: Mount[];
    }

    export interface ContainerConfig {
        /** A string value containing the hostname to use for the container. This must be a valid RFC 1123 hostname. */
        Hostname?: string;
        /** A string value containing the domain name to use for the container. */
        Domainname?: string;
        /** A string value specifying the user inside the container. */
        User?: string;
        /** Boolean value, attaches to `stdin`. */
        AttachStdin?: Boolean;
        /** Boolean value, attaches to `stdout`. */
        AttachStdout?: Boolean;
        /** Boolean value, attaches to `stderr`. */
        AttachStderr?: Boolean;
        /** Boolean value, Attach standard streams to a `tty`, including `stdin` if it is not closed. */
        Tty?: boolean;
        /** Boolean value, opens `stdin`, */
        OpenStdin?: Boolean;
        /** Boolean value, close `stdin` after the 1 attached client disconnects. */
        StdinOnce?: boolean;
        /** A list of environment variables in the form of `["VAR=value"[,"VAR2=value2"]]`. */
        Env?: string[];
        /** Adds a map of labels to a container. To specify a map: `{"key":"value"[,"key2":"value2"]}`. */
        Labels?: Dictionary<string>;
        /** Command to run specified as a string or an array of strings. */
        Cmd?: string | string[];
        /** Set the entry point for the container as a string or an array of strings. */
        Entrypoint?: string;
        /** A string specifying the image name to use for the container. */
        Image?: string;
        /** An object mapping mount point paths (strings) inside the container to empty objects. */
        Volumes?: Dictionary<VolumeConfig>; 
        /** A string specifying the working directory for commands to run in. */
        WorkingDir?: string;
        /** Boolean value, when true disables networking for the container. */
        NetworkDisabled?: boolean;
        /** An object mapping ports to an empty object in the form of: `"ExposedPorts": { "<port>/<tcp|udp>: {}" }`. */
        ExposedPorts?: Dictionary<ExposedPort>;
        /** Signal to stop a container as a string or unsigned integer. `SIGTERM` by default. */
        StopSignal?: string;
        MacAddress?: string;
        OnBuild?: any;
    }

    export interface ExposedPort {
    }

    export interface VolumeConfig {
    }

    export interface HostConfig {
        /**
         * A list of volume bindings for this container. Each volume binding is a string in one of these forms:
         *  - host-src:container-dest to bind-mount a host path into the container. Both host-src, and container-dest must be an absolute path.
         *  - host-src:container-dest:ro to make the bind-mount read-only inside the container. Both host-src, and container-dest must be an absolute path.
         *  - volume-name:container-dest to bind-mount a volume managed by a volume driver into the container. container-dest must be an absolute path.
         *  - volume-name:container-dest:ro to mount the volume read-only inside the container. container-dest must be an absolute path.
         */
        Binds?: string[];
        /** A list of links for the container. Each link entry should be in the form of `container_name:alias`. */
        Links?: string[];

        /** Memory limit in bytes. (0 for no limit). */
        Memory?: number;
        /** Total memory limit (memory + swap); set `-1` to enable unlimited swap. You must use this with `memory` and make the swap value larger than `memory`. */
        MemorySwap?: number;
        /** Memory soft limit in bytes. */
        MemoryReservation?: number;
        /** Kernel memory limit in bytes. */
        KernelMemory?: number;
        /** An integer value containing the usable percentage of the available CPUs. (Windows daemon only) */
        CpuPercent?: number;
        /** An integer value containing the container’s CPU Shares (ie. the relative weight vs other containers). */
        CpuShares?: number;
        /** The length of a CPU period in microseconds. */
        CpuPeriod?: number;
        /** Microseconds of CPU time that the container can get in a CPU period. */
        CpuQuota?: number;
        /** String value containing the cgroups CpusetCpus to use. */
        CpusetCpus?: string;
        /** Memory nodes (MEMs) in which to allow execution (0-3, 0,1). Only effective on NUMA systems. */
        CpusetMems?: string;

        /** Maximum IO absolute rate in terms of IOps. */
        IOMaximumBandwidth?: number;
        /** Maximum IO absolute rate in terms of bytes per second. */
        IOMaximumIOps?: number;
        /** Block IO weight (relative weight) accepts a weight value between 10 and 1000. */
        BlkioWeight?: number;
        /** Block IO weight (relative device weight) in the form of: `"BlkioWeightDevice": [{"Path": "device_path", "Weight": weight}]` */
        BlkioWeightDevice?: BlkioDeviceWeight[]; 
        /** Limit read rate (bytes per second) from a device in the form of: `"BlkioDeviceReadBps": [{"Path": "device_path", "Rate": rate}]`, for example: `"BlkioDeviceReadBps": [{"Path": "/dev/sda", "Rate": "1024"}]"` */
        BlkioDeviceReadBps?: BlkioDeviceRate[]; 
        /** Limit write rate (bytes per second) to a device in the form of: `"BlkioDeviceWriteBps": [{"Path": "device_path", "Rate": rate}]`, for example: `"BlkioDeviceWriteBps": [{"Path": "/dev/sda", "Rate": "1024"}]"` */
        BlkioDeviceWriteBps?: BlkioDeviceRate[]; 
        /** Limit read rate (IO per second) from a device in the form of: `"BlkioDeviceReadIOps": [{"Path": "device_path", "Rate": rate}]`, for example: `"BlkioDeviceReadIOps": [{"Path": "/dev/sda", "Rate": "1000"}]` */
        BlkioDeviceReadIOps?: BlkioDeviceRate[]; 
        /** Limit write rate (IO per second) to a device in the form of: `"BlkioDeviceWriteIOps": [{"Path": "device_path", "Rate": rate}]`, for example: `"BlkioDeviceWriteIOps": [{"Path": "/dev/sda", "Rate": "1000"}]` */
        BlkioDeviceWriteIOps?: BlkioDeviceRate[];

        /** Tune a container’s memory swappiness behavior. Accepts an integer between 0 and 100. */
        MemorySwappiness?: number;
        /** Boolean value, whether to disable OOM Killer for the container or not. */
        OomKillDisable?: boolean;
        /** An integer value containing the score given to the container in order to tune OOM killer preferences. */
        OomScoreAdj?: number;
        /** Set the PID (Process) Namespace mode for the container; `"container:<name|id>"`: joins another container’s PID namespace `"host"`: use the host’s PID namespace inside the container */
        PidMode?: string;
        /** Tune a container’s pids limit. Set -1 for unlimited. */
        PidsLimit?: number;
        /** A map of exposed container ports and the host port they should map to. A JSON object in the form `{ <port>/<protocol>: [{ "HostPort": "<port>" }] }` Take note that port is specified as a string and not an integer value. */
        PortBindings?: Dictionary<PortBinding[]>;
        /** Allocates a random host port for all of a container’s exposed ports. Specified as a boolean value. */
        PublishAllPorts?: boolean;
        /** Gives the container full access to the host. Specified as a boolean value. */
        Privileged?: boolean;
        /** Mount the container’s root filesystem as read only. Specified as a boolean value. */
        ReadonlyRootfs?: boolean;
        
        /** A list of DNS servers for the container to use. */
        Dns?: string[];
        /** A list of DNS options. */
        DnsOptions?: string[];
        /**  A list of DNS search domains. */
        DnsSearch?: string[];
        /** A list of hostnames/IP mappings to add to the container’s /etc/hosts file. Specified in the form `["hostname:IP"]`. */
        ExtraHosts?: string[];
        /** A list of volumes to inherit from another container. Specified in the form `<container name>[:<ro|rw>]`. */
        VolumesFrom?: string[];

        /** A list of kernel capabilities to add to the container. */
        CapAdd?: string[];
        /** A list of kernel capabilities to drop from the container. */
        CapDrop?: string[];
        /** A list of additional groups that the container process will run as. */
        GroupAdd?: string[];

        /**
         * The behavior to apply when the container exits. 
         * The value is an object with a Name property of either :
         *  - "always" to always restart, 
         *  - "unless-stopped" to restart always except when user has manually stopped the container
         *  - "on-failure" to restart only when the container exit code is non-zero. 
         *     If on-failure is used, `MaximumRetryCount` controls the number of times to retry before giving up.
         * 
         * The default is not to restart. 
         * (optional) An ever increasing delay (double the previous delay, starting at 100mS) is added before each restart to prevent flooding the server.
         */
        RestartPolicy?: "always" | "on-failure" | "unless-stopped";
        /** If `on-failure` is used, it controls the number of times to retry before giving up. */
        MaximumRetryCount?: number;

        /** Sets the usernamespace mode for the container when usernamespace remapping option is enabled. supported values are: host. */
        UsernsMode?: string;
        /** 
         * Sets the networking mode for the container. Supported standard values are: `bridge`, `host`, `none`, and `container:<name|id>`.
         * Any other value is taken as a custom network’s name to which this container should connect to.
         */
        NetworkMode?: "bridge" | "host" | "none" | string;
        /** A list of devices to add to the container specified as a JSON object in the form `{ "PathOnHost": "/dev/deviceName", "PathInContainer": "/dev/deviceName", "CgroupPermissions": "mrw"}`. */
        Devices?: Dictionary<string>;
        /** A list of ulimits to set in the container, specified as `{ "Name": <name>, "Soft": <soft limit>, "Hard": <hard limit> }`, for example: `Ulimits: { "Name": "nofile", "Soft": 1024, "Hard": 2048 }`. */
        Ulimits?: UlimitConfig[];
        /** A list of kernel parameters (sysctls) to set in the container, specified as `{ <name>: <Value> }`, for example: `{ "net.ipv4.ip_forward": "1" }`. */
        Sysctls?: Dictionary<string>;
        /** A list of string values to customize labels for MLS systems, such as SELinux. */
        SecurityOpt?: string[];
        /** Storage driver options per container. Options can be passed in the form `{"size":"120G"}`. */
        StorageOpt?: Dictionary<string>;
        /** 
         * Log configuration for the container, specified as a JSON object in the form `{ "Type": "<driver_name>", "Config": {"key1": "val1"}}.
         * Available types: `json-file`, `syslog`, `journald`, `gelf`, `fluentd`, `awslogs`, `splunk`, `etwlogs`, `none`.
         */
        LogConfig?: LogConfig;

        /** 
         * Path to `cgroups` under which the container’s cgroup is created. 
         * If the path is not absolute, the path is considered to be relative to the `cgroups` path of the init process.
         * Cgroups are created if they do not already exist.
         */
        CgroupParent?: string;
        /** Driver that this container users to mount volumes. */
        VolumeDriver?: string;
        /** Size of `/dev/shm` in bytes. The size must be greater than 0. If omitted the system uses 64MB. */
        ShmSize?: number;
    }

    export interface BlkioDeviceWeight {
        Path: string;
        Weight: string | number;
    }

    export interface BlkioDeviceRate {
        Path: string;
        Rate: string | number;
    }

    export interface PortBinding {
        HostPort: string | number;
    }

    export interface UlimitConfig {
        Name: string;
        Soft: number;
        Hard: number;
    }

    export interface LogConfig {
        Type: string;
        Config: Object;
    }

    export interface NetworkSettings extends BaseNetwork {
        Bridge: string;
        SandboxID: string;
        HairpinMode: boolean;
        LinkLocalIPv6Address: string;
        LinkLocalIPv6PrefixLen: number;
        Ports: string[];
        SandboxKey: string;
        SecondaryIPAddresses: string[];
        SecondaryIPv6Addresses: string[];
        Networks: Dictionary<Network>;
    }

    export interface Network extends BaseNetwork {
        NetworkID: string;
        EndpointID: string;
    }

    export interface BaseNetwork {
        Gateway: string;
        GlobalIPv6Address: string;
        GlobalIPv6PrefixLen: number;
        IPAddress: string;
        IPPrefixLen: number;
        IPv6Gateway: string;
        MacAddress: string;
    }

    export interface ContainerState {
        Error: string;
        ExitCode: number;
        FinishedAt: string;
        OOMKilled: boolean;
        Dead: boolean;
        Paused: boolean;
        Pid: number;
        Restarting: boolean;
        Running: boolean;
        StartedAt: string;
        Status: string;
    }

    export interface ContainerMount {
        Name: string;
        Source: string;
        Destination: string;
        Driver: string;
        Mode: string;
        RW: boolean;
        Propagation: string;
    }

    export interface RenameOptions {
        /** New name for the container. */
        name: string;
    }

    export interface UpdateOptions {
        /** Block IO weight (relative weight) accepts a weight value between 10 and 1000. */
        BlkioWeight?: number;
        /** An integer value containing the container’s CPU Shares (ie. the relative weight vs other containers). */
        CpuShares?: number;
        /** The length of a CPU period in microseconds. */
        CpuPeriod?: number;
        /** Microseconds of CPU time that the container can get in a CPU period. */
        CpuQuota?: number;
        /** String value containing the cgroups CpusetCpus to use. */
        CpusetCpus?: string;
        /** Memory nodes (MEMs) in which to allow execution (0-3, 0,1). Only effective on NUMA systems. */
        CpusetMems?: string;
        /** Memory limit in bytes. (0 for no limit). */
        Memory?: number;
        /** Total memory limit (memory + swap); set `-1` to enable unlimited swap. You must use this with `memory` and make the swap value larger than `memory`. */
        MemorySwap?: number;
        /** Memory soft limit in bytes. */
        MemoryReservation?: number;
        /** Kernel memory limit in bytes. */
        KernelMemory?: number;
        RestartPolicy?: RestartPolicy;
    }

    export interface UpdateResult {
        Warnings: string[];
    }

    export interface TopOptions {
        /** `ps` arguments to use (e.g., `aux`), defaults to `-ef` */
        ps_aux?: string;
    }

    export interface TopResult {
        Titles: string[];
        Processes: string[];
    }

    export interface ChangesResult {
        /** Change's path. */
        Path: string;
        /**
         * Kind of change:
         *  - 0: Modify
         *  - 1: Add
         *  - 2: Delete
         */
        Kind: 0 | 1 | 2;
    }

    export interface StartOptions {
        /** 
         * Override the key sequence for detaching a container. 
         * Format is a single character `[a-Z]` or `ctrl-<value>` where `<value>` is one of: `a-z`, `@`, `^`, `[`, , or `_`.
         */
        detachKeys?: string;
    }

    export interface ExecOptions {
        /** Attaches to `stdin` of the `exec` command. */
        AttachStdin?: Boolean;
        /** Attaches to `stdout` of the `exec` command. */
        AttachStdout?: Boolean;
        /** Attaches to `stderr` of the `exec` command. */
        AttachStderr?: Boolean;
        /** Command to run specified as a string or an array of strings. */
        Cmd?: string | string[];
        /** 
         * Override the key sequence for detaching a container. 
         * Format is a single character `[a-Z]` or `ctrl-<value>` where `<value>` is one of: `a-z`, `@`, `^`, `[`, , or `_`.
         */
        DetachKeys?: string;
        /** Runs the exec process with extended privileges. */
        Privileged?: Boolean;
        /** Allocate a pseudo-TTY. */
        Tty?: Boolean;
        /** 
         * A string value specifying the user, and optionally, group to run the exec process inside the container.
         * Format is one of: `"user"`, `"user:group"`, `"uid"`, or `"uid:gid"`.
         */
        User?: string;
    }

    export interface CommitOptions {
        repo?: string;
        tag?: string;
        comment?: string;
        author?: string;
        pause?: Boolean;
        changes?: string;

        Hostname?: string;
        Domainname?: string;
        User?: string;
        AttachStdin?: boolean;
        AttachStdout?: boolean;
        AttachStderr?: boolean;
        Tty?: boolean;
        OpenStdin?: boolean;
        StdinOnce?: boolean;
        Env?: null,
        Cmd?: string;
        Mounts?: Mount[];
        Labels?: Dictionary<string>;
        WorkingDir?: string;
        NetworkDisabled?: boolean;
        ExposedPorts?: Dictionary<ExposedPort>;
    }

    export interface Port {
        PrivatePort: number;
        PublicPort: number;
        Type: "tcp" | "udp";
    }

    export interface Mount {
        Source: string;
        Destination?: string;
        Mode?: string;
        RW?: Boolean;
        Driver?: string;
        Propagation?: string;
    }

    export interface CommitResult {
        Id: string;
    }

    export interface StopOptions {
        /** Number of seconds to wait before killing the container */
        t?: number;
    }

    export interface RestartOptions {
        /** Number of seconds to wait before killing the container */
        t?: number;
    }

    export interface KillOptions {
        /** 
         * Signal to send to the container: `integer` or `string` like `SIGINT`.
         * When not set, `SIGKILL` is assumed and the call waits for the container to exit.
         */
        signal?: number | string;
    }

    export interface ResizeOptions {
        /** Height of `tty` session. */
        h: number;
        /** Width of `tty` session. */
        w: number;
    }

    export interface AttachOptions {
        /** 
         * Override the key sequence for detaching a container. 
         * Format is a single character `[a-Z]` or `ctrl-<value>` where `<value>` is one of: `a-z`, `@`, `^`, `[`, , or `_`.
         */
        detachKeys?: string;
        /** Return logs. Default `false`. */
        logs?: Boolean;
        /** Return stream. Default `false`. */
        stream?: Boolean;
        /** If `stream=true`, attach to `stdin`. Default `false`. */
        stdin?: Boolean;
        /** If `logs=true`, return `stdout` log, if `stream=true`, attach to `stdout`. Default `false`. */
        stdout?: Boolean;
        /** If `logs=true`, return `stderr` log, if `stream=true`, attach to `stderr`. Default `false`. */
        stderr?: Boolean;
        hijack?: Boolean;
    }

    export interface WaitResult {
        /** Container's exit code. */
        StatusCode: number;
    }
    
    export interface RemoveOptions {
        /** Remove the volumes associated to the container. Default `false`. */
        v?: Boolean;
        /** Kill then remove the container. Default `false`. */
        force?: Boolean;
    }

    export interface CopyOptions {

    }

    export interface ArchiveOptions {
        /**
         * Required. Resource in the container’s filesystem to archive.
         * If not an absolute path, it is relative to the container’s root directory. 
         * The resource specified by `path` must exist. 
         * To assert that the resource is expected to be a directory, `path` should end in `/` or `/.` (assuming a `path` separator of `/`).
         * If `path` ends in `/`. then this indicates that only the contents of the `path` directory should be copied.
         * A symlink is always resolved to its target.
         * 
         * Note: It is not possible to copy certain system files such as resources under /proc, /sys, /dev, and mounts created by the user in the container.
         */
        path: string;
    }

    export interface ArchiveInformations {
        name: string;
        size: number;
        mode: string;
        mtime: string;
        linkTarget: string;
    }

    export interface PutArchiveOptions extends ArchiveOptions {
        /** If `1`, `true`, or `True` then it will be an error if unpacking the given content would cause an existing directory to be replaced with a non-directory and vice versa. */
        noOverwriteDirNonDir?: Boolean;
    }

    export interface LogsOptions {
        /** Show extra details provided to logs. Default `false`. */
        details?: Boolean;
        /** Return stream. Default `false`. */
        follow?: Boolean;
        /** Show `stdout` log. Default `false`. */
        stdout?: Boolean;
        /** Show `stderr` log. Default `false`. */
        stderr?: Boolean;
        /** UNIX timestamp (integer) to filter logs. Specifying a timestamp will only output log-entries since that timestamp. Default: `0` (unfiltered) */
        since?: number;
        /** Print timestamps for every log line. Default `false`. */
        timestamps?: Boolean;
        /** Output specified number of lines at the end of logs: `all` or `<number>`. Default `all`. */
        tail?: "all" | number;
    }

    export interface StatsOptions {
        /** `0` or `false` to pull stats once then disconnect. Default `true`. */
        stream?: Boolean;
    }

    export interface StatsResult {
        /** Date */
        read: string;
        pid_stats: Dictionary<number>;
        networks: Dictionary<NetworkStatistics>;
        memory_stats: MemoryStatistics;
        blkio_stats: Object;
        cpu_stats: CpuStatistics;
        /** Last read's CPU statistic, which is used for calculating the cpu usage percent. It is not the exact copy of the “cpu_stats” field. */
        precpu_stats: CpuStatistics;
    }

    export interface NetworkStatistics {
        rx_bytes: number;
        rx_dropped: number;
        rx_errors: number;
        rx_packets: number;
        tx_bytes: number;
        tx_dropped: number;
        tx_errors: number;
        tx_packets: number;
    }

    export interface MemoryStatistics {
        stats: {
            total_pgmajfault: number;
            cache: number;
            mapped_file: number;
            total_inactive_file: number;
            pgpgout: number;
            rss: number;
            total_mapped_file: number;
            writeback: number;
            unevictable: number;
            pgpgin: number;
            total_unevictable: number;
            pgmajfault: number;
            total_rss: number;
            total_rss_huge: number;
            total_writeback: number;
            total_inactive_anon: number;
            rss_huge: number;
            hierarchical_memory_limit: number;
            total_pgfault: number;
            total_active_file: number;
            active_anon: number;
            total_active_anon: number;
            total_pgpgout: number;
            total_cache: number;
            inactive_anon: number;
            active_file: number;
            pgfault: number;
            inactive_file: number;
            total_pgpgin: number;
        };
        max_usage: number;
        usage: number;
        failcnt: number;
        limit: number;
    }

    export interface CpuStatistics {
        cpu_usage: {
            percpu_usage: number[];
            usage_in_usermode: number;
            total_usage: number;
            usage_in_kernelmode: number;
        };
        system_cpu_usage: number;
        throttling_data: {
            periods: number;
            throttled_periods: number;
            throttled_time: number;
        };
    }

    export interface RestartPolicy {
        Name?: string;
        MaximumRetryCount?: number;
    }

}

export = Container;
}
declare module 'dockerode/lib/container' {
import main = require('~dockerode/lib/container');
export = main;
}

// Generated by typings
// Source: https://raw.githubusercontent.com/typed-contrib/dockerode/b88ec97d60fe98523e15e0fcc0e578030fdddcf4/lib/image.d.ts
declare module '~dockerode/lib/image' {
// Type definitions for dockerode v2.3.1
// Project: https://github.com/apocas/dockerode
// Definitions by: Maxime LUCE <https://github.com/SomaticIT/>
// Definitions: https://github.com/typed-contrib/dockerode

import * as Modem from '~dockerode~docker-modem';
import { Readable } from 'stream';

import { Boolean, Callback, AuthConfig } from '~dockerode/lib/util';
import { ContainerConfig, ExposedPort } from '~dockerode/lib/container';

/** Represents an Image. */
class Image {
    public modem: Modem;
    public name: string;
    
    /**
     * Constructs a new Image instance.
     * 
     * @param modem     docker-modem.
     * @param name      Image's name.
     */
    constructor(modem: Modem, name: string);

    /**
     * Get low-level information about this Image.
     * 
     * @param callback  Callback which will be called when call ends.
     */
    public inspect(callback: Callback<Image.ImageResult>): void;

    /**
     * Does not query Docker.
     * Only return {"id":"someid"} as String.
     */
    public inspect(): string;
    
    /**
     * Return the history of this Image.
     * 
     * @param callback  Callback which will be called when call ends.
     */
    public history(callback: Callback<Image.HistoryResult[]>): void;

    /**
     * Get a tarball containing all images.
     * 
     * @param callback  Callback with data stream.
     */
    public get(callback: Callback<Readable>): void;

    /**
     * Push this Image on the registry.
     * If you wish to push an image on to a private registry, that image must already have a tag into a `repository` which references that registry `hostname` and `port`.
     * This `repository` name should then be used in the URL.
     * This duplicates the command line’s flow.
     * The push is cancelled if the HTTP connection is closed.
     * 
     * @param callback  Callback which will be called when call ends.
     * @param [auth]    Registry authentication.
     */
    public push(callback: Callback<Readable>, auth?: AuthConfig): void;
    /**
     * Push this Image on the registry.
     * If you wish to push an image on to a private registry, that image must already have a tag into a `repository` which references that registry `hostname` and `port`.
     * This `repository` name should then be used in the URL.
     * This duplicates the command line’s flow.
     * The push is cancelled if the HTTP connection is closed.
     * 
     * @param opts      Image push options.
     * @param callback  Callback which will be called when call ends.
     * @param [auth]    Registry authentication.
     */
    public push(opts: Image.PushOptions, callback: Callback<Readable>, auth?: AuthConfig): void;

    /**
     * Tag this Image into a repository.
     * 
     * @param opts      Image tag options (like `repo`).
     * @param callback  Callback which will be called when call ends.
     */
    public tag(opts: Image.TagOptions, callback: Callback<void>): void;

    /**
     * Remove this Image from the filesystem.
     * 
     * @param callback  Callback which will be called when call ends.
     */
    public remove(callback: Callback<Image.RemoveResult[]>): void;
    /**
     * Remove this Image from the filesystem.
     * 
     * @param opts      Image remove options.
     * @param callback  Callback which will be called when call ends.
     */
    public remove(opts: Image.RemoveOptions, callback: Callback<Image.RemoveResult[]>): void;

}

namespace Image {
    export interface ImageResult {
        Id: string;
        Container: string;
        Comment: string;
        Os: string;
        Architecture: string;
        Parent: string;
        ContainerConfig: ContainerConfig;
        DockerVersion: string;
        VirtualSize: number;
        Size: number;
        Author: string;
        Created: string;
        GraphDriver: {
            Name: string;
            Data: any
        };
        RepoDigests: string[];
        RepoTags: string[];
        Config: ContainerConfig;
        RootFS: {
            Type: string;
            Layers: string[];
        };
    }

    export interface HistoryResult {
        Id: string;
        Created: number;
        CreatedBy: string;
        Tags: string[];
        Size: number;
        Comment: string;
    }
    
    export interface PushOptions {
        /** The tag to associate with the image on the registry. This is optional. */
        tag?: string;
    }
    
    export interface TagOptions {
        /** The repository to tag in. */
        repo?: string;
        /** The new tag name. */
        tag?: string;
    }
    
    export interface RemoveOptions {
        /** `1`/`True`/`true` or `0`/`False`/`false`, default `false`. */
        force?: Boolean;
        /** `1`/`True`/`true` or `0`/`False`/`false`, default `false`. */
        noprune?: Boolean;
    }

    export type RemoveResult = { Untagged: string; } | { Deleted: string; };
}

export = Image;
}
declare module 'dockerode/lib/image' {
import main = require('~dockerode/lib/image');
export = main;
}

// Generated by typings
// Source: https://raw.githubusercontent.com/typed-contrib/dockerode/b88ec97d60fe98523e15e0fcc0e578030fdddcf4/lib/volume.d.ts
declare module '~dockerode/lib/volume' {
// Type definitions for dockerode v2.3.1
// Project: https://github.com/apocas/dockerode
// Definitions by: Maxime LUCE <https://github.com/SomaticIT/>
// Definitions: https://github.com/typed-contrib/dockerode

import * as Modem from '~dockerode~docker-modem';
import { Boolean, Callback, Dictionary } from '~dockerode/lib/util';

/** Represents an Volume. */
class Volume {
    public modem: Modem;
    public name: string;
    
    /**
     * Constructs a new Volume instance.
     * 
     * @param modem     docker-modem.
     * @param name        Volume's name.
     */
    constructor(modem: Modem, name: string);

    /**
     * Get information about this Volume.
     * 
     * @param callback  Callback which will be called when call ends.
     */
    public inspect(callback: Callback<Volume.InspectResult>): void;

    /** Does not query Docker. Only return `{"id":"someid"}`. */
    public inspect(): string;
    
    /**
     * Remove this volume.
     * 
     * @param callback  Callback which will be called when call ends.
     */
    public remove(callback: Callback<void>): void;

    /**
     * Remove this volume.
     * 
     * @param opts      Volume remove options.
     * @param callback  Callback which will be called when call ends.
     */
    public remove(opts: Volume.RemoveOptions, callback: Callback<void>): void;
}

namespace Volume {
    export interface VolumeResult {
        Volumes: InspectResult[];
        Warnings: string[];
    }

    export interface InspectResult {
        /** Name of the volume. */
        Name: string;
        /** Name of the volume driver used by the volume. */
        Driver: string;
        /** Mount path of the volume on the host. */
        Mountpoint: string;
        /** 
         * Low-level details about the volume, provided by the volume driver. 
         * Details are returned as a map with key/value pairs: `{"key":"value","key2":"value2"}`. 
         * The Status field is optional, and is omitted if the volume driver does not support this feature.
         */
        Status: Dictionary<string>;
        /** Labels set on the volume, specified as a map: `{"key":"value","key2":"value2"}`. */
        Labels: Dictionary<string>;
        /** Scope describes the level at which the volume exists, can be one of `global` for cluster-wide or `local` for machine level. The default is `local`. */
        Scope: "global" | "local";
    }

    export interface RemoveOptions {
    }
}

export = Volume;
}
declare module 'dockerode/lib/volume' {
import main = require('~dockerode/lib/volume');
export = main;
}

// Generated by typings
// Source: https://raw.githubusercontent.com/typed-contrib/dockerode/b88ec97d60fe98523e15e0fcc0e578030fdddcf4/lib/network.d.ts
declare module '~dockerode/lib/network' {
// Type definitions for dockerode v2.3.1
// Project: https://github.com/apocas/dockerode
// Definitions by: Maxime LUCE <https://github.com/SomaticIT/>
// Definitions: https://github.com/typed-contrib/dockerode

import * as Modem from '~dockerode~docker-modem';
import { Readable } from 'stream';

import { Boolean, Callback, Dictionary } from '~dockerode/lib/util';
import { ContainerConfig, ExposedPort } from '~dockerode/lib/container';

/** Represents an Network. */
class Network {
    public modem: Modem;
    public id: string;
    
    /**
     * Constructs a new Network instance.
     * 
     * @param modem     docker-modem.
     * @param id        Network's ID.
     */
    constructor(modem: Modem, id: string);

    /**
     * Get low-level information about this Network.
     * 
     * @param callback  Callback which will be called when call ends.
     */
    public inspect(callback: Callback<Network.NetworkResult>): void;

    /** Does not query Docker. Only return `{"id":"someid"}`. */
    public inspect(): string;
    
    /**
     * Remove this Network.
     * 
     * @param callback  Callback which will be called when call ends.
     */
    public remove(callback: Callback<void>): void;
    /**
     * Remove this Network.
     * 
     * @param opts      Network remove options.
     * @param callback  Callback which will be called when call ends.
     */
    public remove(opts: Network.RemoveOptions, callback: Callback<void>): void;
    
    /**
     * Connects a container to a network.
     * 
     * @param callback  Callback which will be called when call ends.
     */
    public connect(callback: Callback<void>): void;
    /**
     * Connects a container to a network.
     * 
     * @param opts      Network connect options.
     * @param callback  Callback which will be called when call ends.
     */
    public connect(opts: Network.ConnectOptions, callback: Callback<void>): void;
    
    /**
     * Disconnects a container to a network.
     * 
     * @param callback  Callback which will be called when call ends.
     */
    public disconnect(callback: Callback<void>): void;
    /**
     * Disconnects a container to a network.
     * 
     * @param opts      Network disconnect options.
     * @param callback  Callback which will be called when call ends.
     */
    public disconnect(opts: Network.DisconnectOptions, callback: Callback<void>): void;
}

namespace Network {
    export interface NetworkResult extends NetworkDefinition {
        Id: string;
        Scope: string;
        Containers: Dictionary<ContainerConfig>;
    }

    export interface NetworkDefinition {
        /** The new network’s name. this is a mandatory field */
        Name: string;
        /** Requests daemon to check for networks with same name */
        CheckDuplicate?: Boolean;
        /** Name of the network driver plugin to use. Defaults to `bridge` driver. */
        Driver?: string;
        /** Enable IPv6 on the network. */
        EnableIPv6?: Boolean;
        /** Optional custom IP scheme for the network */
        IPAM?: Network.IPAM;
        /** Restrict external access to the network. */
        Internal?: boolean;
        /** Network specific options to be used by the drivers. */
        Options?: Dictionary<string>;
        /** Labels to set on the network, specified as a map: `{"key":"value" [,"key2":"value2"]}`. */
        Labels?: Dictionary<string>;
    }

    export interface IPAM {
        Driver?: string;
        Config?: Network.IPAMConfig[];
        Options?: Dictionary<string>;
    }

    export interface IPAMConfig {
        Subnet: string;
        Gateway: string;
        IPRange?: string;
    }

    export interface ContainerConfig {
        Name: string;
        EndpointID: string;
        MacAddress: string;
        IPv4Address: string;
        IPv6Address: string;
    }

    export interface RemoveOptions {
    }
    
    export interface ConnectOptions {
        /** Container `id`/`name` to be connected to the network. */
        container: string;
    }
    
    export interface DisconnectOptions {
        /** Container `id`/`name` to be disconnected from a network */
        Container: string;
        /** Force the container to disconnect from a network. */
        Force?: Boolean;
    }
}

export = Network;
}
declare module 'dockerode/lib/network' {
import main = require('~dockerode/lib/network');
export = main;
}

// Generated by typings
// Source: https://raw.githubusercontent.com/typed-contrib/dockerode/b88ec97d60fe98523e15e0fcc0e578030fdddcf4/lib/service.d.ts
declare module '~dockerode/lib/service' {
// Type definitions for dockerode v2.3.1
// Project: https://github.com/apocas/dockerode
// Definitions by: Maxime LUCE <https://github.com/SomaticIT/>
// Definitions: https://github.com/typed-contrib/dockerode

import * as Modem from '~dockerode~docker-modem';

import { Boolean, Callback, Dictionary } from '~dockerode/lib/util';

/** Represents an Service. */
class Service {
    public modem: Modem;
    public id: string;
    
    /**
     * Constructs a new Service instance.
     * 
     * @param modem     docker-modem.
     * @param id        Service's ID or name.
     */
    constructor(modem: Modem, id: string);

    /**
     * Get information about this Service.
     * 
     * @param callback  Callback which will be called when call ends.
     */
    public inspect(callback: Callback<Service.ServiceResult>): void;

    /** Does not query Docker. Only return `{"id":"someid"}`. */
    public inspect(): string;
    
    /**
     * Stop and remove this Service.
     * 
     * @param callback  Callback which will be called when call ends.
     */
    public remove(callback: Callback<void>): void;

    /**
     * Update a service. 
     * When using this endpoint to create a service using a private repository from the registry, the `X-Registry-Auth` header can be used to update the authentication information for that is stored for the service. 
     * The header contains a base64-encoded AuthConfig object. Refer to the create an image section for more details.
     * 
     * @param opts      Service update options.
     * @param callback  Callback which will be called when call ends.
     */
    public update(opts: Service.UpdateOptions, callback: Callback<void>): void;
}

namespace Service {
    export interface ServiceResult {
        ID: string;
        Version: {
            Index: number;
        };
        CreatedAt: string;
        UpdatedAt: string;
        Spec: ServiceDefinition;
        Endpoint: {
            Spec: EndpointSpec;
            Ports?: Port[];
            VirtualIPs?: VirtualIP[];
        };
    }

    export interface UpdateOptions extends ServiceDefinition {
        version?: number;
    }

    export interface ServiceDefinition {
        /** User-defined name for the service. */
        Name?: string;
        /** A map of labels to associate with the service (e.g., `{"key":"value"[,"key2":"value2"]}`). */
        Labels?: Dictionary<string>;
        /** Specification of the tasks to start as part of the new service. */
        TaskTemplate?: TaskTemplate,
        /** Scheduling mode for the service (`replicated` or `global`, defaults to `replicated`). */
        Mode?: ReplicaMode | GlobalMode,
        /** Specification for the update strategy of the service. */
        UpdateConfig?: UpdateConfig;
        /** Array of network names or IDs to attach the service to. */
        Networks?: string[];
        /** Properties that can be configured to access and load balance a service. */
        EndpointSpec?: EndpointSpec;
    }

    export interface TaskTemplate {
        /** Container settings for containers started as part of this task. */
        ContainerSpec?: ContainerSpec;
        /** Resource requirements which apply to each individual container created as part of the service. */
        Resources?: Resources;
        /** Specification for the restart policy which applies to containers created as part of this service. */
        RestartPolicy?: RestartPolicy;
        /** An array of constraints. */
        Placements?: string[];
    }

    export interface ContainerSpec {
        /** A string specifying the image name to use for the container. */
        Image?: string;
        /** The command to be run in the image. */
        Command?: string;
        /** Arguments to the command. */
        Args?: string[];
        /** A list of environment variables in the form of `["VAR=value"[,"VAR2=value2"]]`. */
        Env?: string[];
        /** A string specifying the working directory for commands to run in. */
        Dir?: string;
        /** A string value specifying the user inside the container. */
        User?: string;
        /** A map of labels to associate with the service (e.g., `{"key":"value"[,"key2":"value2"]}`). */
        Labels?: Dictionary<string>;
        /** Specification for mounts to be added to containers created as part of the new service. */
        Mounts?: Mount[];
    }

    export interface Mount {
        /** Mount source (e.g. a volume name, a host path). */
        Source: string;
        /** Container path. */
        Target?: string;
        /** The mount type (`bind`, or `volume`). */
        Type?: "bind" | "volume";
        /** A boolean indicating whether the mount should be read-only. */
        ReadOnly?: Boolean;
        /** Optional configuration for the bind type */
        BindOptions?: {
            /** A propagation mode with the value `[r]private`, `[r]shared`, or `[r]slave`. */
            Propagation?: "private" | "shared" | "slave" | "rprivate" | "rshared" | "rslave";
        };
        /** Optional configuration for the `volume` type. */
        VolumeOptions?: {
            /** A boolean indicating if volume should be populated with the data from the target. (Default `false`) */
            NoCopy?: Boolean;
            /** User-defined name and labels for the volume. */
            Labels?: Dictionary<string>;
            /** Map of driver-specific options. */
            DriverConfig?: DriverOptions[];
        };
        /** Amount of time to wait for the container to terminate before forcefully killing it. */
        StopGracePeriod?: number;
    }

    export interface DriverOptions {
        /** Name of the driver to use to create the volume. */
        Name: string;
        /** Key/value map of driver specific options. */
        Options: Dictionary<string>;
    }

    export interface Resources {
        /** Define resources limits. */
        Limits?: {
            /** CPU limit */
            CPU?: number;
            /** Memory limit */
            Memory?: number;
        };
        /** Define resources reservation. */
        Reservation ?: {
            /** CPU reservation */
            CPU?: number;
            /** Memory reservation */
            Memory?: number;
        };
    }

    export interface ResourceLimit {
        CPU?: number;
        Memory?: number;
    }

    export interface RestartPolicy {
        /** Condition for restart (`none`, `on-failure`, or `any`). */
        Condition?: "none" | "on-failure" | "any";
        /** Delay between restart attempts. */
        Delay?: number;
        /** Maximum attempts to restart a given container before giving up (default value is `0`, which is ignored). */
        MaxAttempts?: number;
        /** Windows is the time window used to evaluate the restart policy (default value is `0`, which is unbounded). */
        Window?: number;
    }

    export interface UpdateConfig {
        /** Maximum number of tasks to be updated in one iteration (`0` means unlimited parallelism). */
        Parallelism?: number;
        /** Amount of time between updates. */
        Delay?: number;
    }

    export interface EndpointSpec {
        /** The mode of resolution to use for internal load balancing between tasks (`vip` or `dnsrr`). Defaults to `vip` if not provided. */
        Mode?: "vip" | "dnsrr";
        /**
         * List of exposed ports that this service is accessible on from the outside, in the form of: `{"Protocol": <"tcp"|"udp">, "PublishedPort": <port>, "TargetPort": <port>}`.
         * Ports can only be provided if vip resolution mode is used.
         */
        Ports?: Port[];
    }

    export interface Port {
        Protocol?: "tcp" | "udp";
        PublishedPort?: number;
        TargetPort?: number;
    }

    export interface ReplicaMode {
        Replicated: {
            Replicas?: number;
        };
    }

    export interface GlobalMode {
        Global: {};
    }

    export interface VirtualIP {
        NetworkID: string;
        Addr: string;
    }
}

export = Service;
}
declare module 'dockerode/lib/service' {
import main = require('~dockerode/lib/service');
export = main;
}

// Generated by typings
// Source: https://raw.githubusercontent.com/typed-contrib/dockerode/b88ec97d60fe98523e15e0fcc0e578030fdddcf4/lib/task.d.ts
declare module '~dockerode/lib/task' {
// Type definitions for dockerode v2.3.1
// Project: https://github.com/apocas/dockerode
// Definitions by: Maxime LUCE <https://github.com/SomaticIT/>
// Definitions: https://github.com/typed-contrib/dockerode

import * as Modem from '~dockerode~docker-modem';
import { Readable } from 'stream';

import { Boolean, Callback, Dictionary } from '~dockerode/lib/util';
import { ServiceDefinition } from '~dockerode/lib/service';
import { IPAMConfig } from '~dockerode/lib/network';

/** Represents an Task. */
class Task {
    public modem: Modem;
    public id: string;

    /**
     * Constructs a new Task instance.
     * 
     * @param modem     docker-modem.
     * @param id        Task's ID or name.
     */
    constructor(modem: Modem, id: string);

    /**
     * Get information about this Task.
     * 
     * @param callback  Callback which will be called when call ends.
     */
    public inspect(callback: Callback<Task.TaskResult>): void;

    /** Does not query Docker. Only return `{"id":"someid"}`. */
    public inspect(): string;
}

namespace Task {
    export interface TaskResult {
        ID: string;
        Version: {
            Index: number;
        },
        CreatedAt: string;
        UpdatedAt: string;
        Spec: ServiceDefinition;
        ServiceID: string;
        Slot: number;
        NodeID: string;
        Status: {
            Timestamp: string;
            State: string;
            Message: string;
            ContainerStatus: {
                ContainerID: string;
                PID: number;
            };
        },
        DesiredState: string;
        NetworksAttachments: NetworkAttachment[];
    }

    export interface NetworkAttachment {
        Network: {
            ID: string;
            Version: {
                Index: 18
            },
            CreatedAt: string;
            UpdatedAt: string;
            Spec: {
                Name: string;
                Labels: Dictionary<string>;
                DriverConfiguration: {},
                IPAMOptions: {
                    Driver: string;
                    Config: IPAMConfig[];
                    Options: Dictionary<string>;
                }
            },
            DriverState: {
                Name: string;
                Options: Dictionary<string>;
            },
            IPAMOptions: {
                Driver: {
                    Name: string;
                },
                Configs: IPAMConfig[]
            }
        },
        Addresses: string[];
    }
}

export = Task;
}
declare module 'dockerode/lib/task' {
import main = require('~dockerode/lib/task');
export = main;
}

// Generated by typings
// Source: https://raw.githubusercontent.com/typed-contrib/dockerode/b88ec97d60fe98523e15e0fcc0e578030fdddcf4/lib/node.d.ts
declare module '~dockerode/lib/node' {
// Type definitions for dockerode v2.3.1
// Project: https://github.com/apocas/dockerode
// Definitions by: Maxime LUCE <https://github.com/SomaticIT/>
// Definitions: https://github.com/typed-contrib/dockerode

import * as Modem from '~dockerode~docker-modem';

import { Callback, Dictionary } from '~dockerode/lib/util';

/** Represents an Node. */
class Node {
    public modem: Modem;
    public id: string;
    
    /**
     * Constructs a new Node instance.
     * 
     * @param modem     docker-modem.
     * @param id        Node's ID.
     */
    constructor(modem: Modem, id: string);
    
    /**
     * Get low-level information about this Node.
     * 
     * @param callback  Callback which will be called when call ends.
     */
    public inspect(callback: Callback<Node.NodeResult>): void;

    /** Does not query Docker. Only return `{"id":"someid"}`. */
    public inspect(): string;
    
    /**
     * Remove this Node from the swarm.
     * 
     * @param callback  Callback which will be called when call ends.
     */
    public remove(callback: Callback<void>): void;

}

namespace Node {
    export interface NodeResult {
        ID: string;
        Version: {
            Index: number;
        },
        CreatedAt: string;
        UpdatedAt: string;
        Spec: {
            Name: string;
            Role: string;
            Availability: string;
            Labels: Dictionary<string>;
        },
        Description: {
            Hostname: string;
            Platform: {
                Architecture: string;
                OS: string;
            },
            Resources: {
                NanoCPUs: number;
                MemoryBytes: number;
            },
            Engine: {
                EngineVersion: string;
                Labels: Dictionary<string>;
                Plugins: Plugin[];
            }
        },
        Status: {
            State: string;
        },
        ManagerStatus: {
            Leader: boolean;
            Reachability: string;
            Addr: string;
        }
    }

    export interface Plugin {
        Type: string;
        Name: string;
    }
}

export = Node;
}
declare module 'dockerode/lib/node' {
import main = require('~dockerode/lib/node');
export = main;
}

// Generated by typings
// Source: https://raw.githubusercontent.com/typed-contrib/dockerode/b88ec97d60fe98523e15e0fcc0e578030fdddcf4/lib/exec.d.ts
declare module '~dockerode/lib/exec' {
// Type definitions for dockerode v2.3.1
// Project: https://github.com/apocas/dockerode
// Definitions by: Maxime LUCE <https://github.com/SomaticIT/>
// Definitions: https://github.com/typed-contrib/dockerode

import * as Modem from '~dockerode~docker-modem';
import { Readable, Duplex } from 'stream';

import { Callback } from '~dockerode/lib/util';

/** Represents an Exec setup. */
class Exec {
    public modem: Modem;
    public id: string;
    
    /**
     * Constructs a new Exec instance.
     * 
     * @param modem     docker-modem
     * @param id        Exec's ID
     */
    constructor(modem: Modem, id: string);

    /**
     * Start this Exec instance.
     * 
     * @param opts      Exec start options.
     * @param callback  Callback with stream.
     */
    public start(opts: Exec.StartOptions, callback: Callback<Readable>): void;

    /**
     * Start this Exec instance.
     * 
     * @param opts      Exec start options.
     * @param callback  Callback with stream.
     */
    public start(opts: {stdin:true} & Exec.StartOptions, callback: Callback<Duplex>): void;

    /**
     * Resizes the `tty` session used by this Exec command.
     * The unit is number of characters.
     * This API is valid only if `tty` was specified as part of creating and starting the `exec` command.
     * 
     * @param opts      Exec resize options.
     * @param callback  Callback which will be called when call ends.
     */
    public resize(opts: Exec.ResizeOptions, callback: Callback<void>): void;

    /**
     * Get low-level information about this Exec instance.
     * 
     * @param callback  Callback which will be called when call ends.
     */
    public inspect(callback: Callback<Exec.InspectResult>): void;

    /**
     * Does not call Docker Remote API.
     * Returns a JSON representation of {"id":"someid"}
     */
    public inspect(): string;
}

namespace Exec {
    export interface StartOptions {
        hijack?: boolean;
        stdin?: boolean;
        /**
         * If `true`, this API returns after starting the `exec` command.
         * Otherwise, this API sets up an interactive session with the `exec` command.
         */
        Detach?: Boolean;
        /** Allocate a pseudo-TTY. */
        Tty?: Boolean;
    }

    export interface ResizeOptions {
        /** Width of the `tty` session. */
        w?: number;
        /** Height of the `tty` session. */
        h?: number;
    }

    export interface InspectResult {
        ID: string;
        ContainerID: string;
        CanRemove: boolean;
        DetachKeys: string;
        ExitCode: number;
        OpenStdin: boolean;
        OpenStdout: boolean;
        OpenStderr: boolean;
        ProcessConfig: {
            arguments: string[];
            entrypoint: string;
            privileged: boolean;
            tty: boolean;
            user: string;
        };
        Running: boolean;
    }
}

export = Exec;
}
declare module 'dockerode/lib/exec' {
import main = require('~dockerode/lib/exec');
export = main;
}

// Generated by typings
// Source: https://raw.githubusercontent.com/typed-contrib/dockerode/b88ec97d60fe98523e15e0fcc0e578030fdddcf4/lib/util.d.ts
declare module '~dockerode/lib/util' {
export type Callback<T> = (err: Error, data: T) => void;
export type Dictionary<T> = { [key: string]: T };
export type Boolean = 1 | 0 | boolean;
export type AuthConfig = Auth | Identity | string;
export type Timestamp = string | number;
export type Filters = string | Dictionary<string | string[]>;

export interface Auth {
    username: string;
    password: string;
    email: string;
}

export interface Identity {
    identitytoken: string;
}
}
declare module 'dockerode/lib/util' {
export * from '~dockerode/lib/util';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/typed-contrib/dockerode/b88ec97d60fe98523e15e0fcc0e578030fdddcf4/lib/docker.d.ts
declare module '~dockerode/lib/docker' {
// Type definitions for dockerode v2.3.1
// Project: https://github.com/apocas/dockerode
// Definitions by: Maxime LUCE <https://github.com/SomaticIT/>
// Definitions: https://github.com/typed-contrib/dockerode

import * as Modem from '~dockerode~docker-modem';
import { EventEmitter } from 'events';
import { Readable, Duplex, Writable } from 'stream';

import * as Container from '~dockerode/lib/container';
import * as Image from '~dockerode/lib/image';
import * as Volume from '~dockerode/lib/volume';
import * as Network from '~dockerode/lib/network';
import * as Service from '~dockerode/lib/service';
import * as Task from '~dockerode/lib/task';
import * as Node from '~dockerode/lib/node';
import * as Exec from '~dockerode/lib/exec';

import { Boolean, Callback, Dictionary, Filters, Timestamp, AuthConfig } from '~dockerode/lib/util';

class Docker extends EventEmitter {
    public modem: Modem;

    constructor(options?: Docker.SocketOptions | Docker.HostOptions);

    /**
     * Create an image either by pulling it from the registry.
     * 
     * @param opts      Image create options.
     * @param callback  Callback which will be called when call ends.
     */
    public createImage(opts: Docker.CreateImageOptions, callback: Callback<Readable>);
    
    /**
     * Create an image either by pulling it from the registry.
     * 
     * @param auth      Authentication options.
     * @param opts      Image create options.
     * @param callback  Callback which will be called when call ends.
     */
    public createImage(auth: AuthConfig, opts: Docker.CreateImageOptions, callback: Callback<Readable>);

    /**
     * Load a tarball with a set of images and tags into docker.
     * 
     * @param file      File to load image from.
     * @param callback  Callback which will be called when call ends.
     */
    public loadImage(file: string, callback: Callback<Readable>);
    /**
     * Load a tarball with a set of images and tags into docker.
     * 
     * @param file      File to load image from.
     * @param opts      Image load options.
     * @param callback  Callback which will be called when call ends.
     */
    public loadImage(file: string, opts: Docker.LoadImageOptions, callback: Callback<Readable>);

    /**
     * Create an image either by importing it.
     * 
     * @param file      File to load image from.
     * @param callback  Callback which will be called when call ends.
     */
    public importImage(file: string, callback: Callback<Readable>);
    /**
     * Create an image either by importing it.
     * 
     * @param file      File to load image from.
     * @param opts      Image import options.
     * @param callback  Callback which will be called when call ends.
     */
    public importImage(file: string, opts: Docker.CreateImageOptions, callback: Callback<Readable>);

    /**
     * Build an image from a Dockerfile.
     * 
     * @param file      Tar stream to build image from.
     * @param callback  Callback which will be called when call ends.
     */
    public buildImage(file: string, callback: Callback<Readable>);
    /**
     * Build an image from a Dockerfile.
     * 
     * @param file      Tar stream to build image from.
     * @param opts      Image build options.
     * @param callback  Callback which will be called when call ends.
     */
    public buildImage(file: string, opts: Docker.BuildImageOptions, callback: Callback<Readable>);

    /**
     * Create an image either by pulling it from the registry.
     * 
     * @param opts      Image create options.
     * @param callback  Callback which will be called when call ends.
     */
    public searchImages(opts: Docker.SearchImagesOptions, callback: Callback<Docker.SearchImagesResult[]>);

    /**
     * Validate credentials for a registry and get identity token, if available, for accessing the registry without password.
     * 
     * @param opts      Container create options.
     * @param callback  Callback which will be called when call ends.
     */
    public checkAuth(opts: Docker.CheckAuthOptions, callback: Callback<Docker.CheckAuthResult>);

    /**
     * Get a Container by ID or name.
     * 
     * @param id        Container's ID or name.
     */
    public getContainer(id: string): Container;
    
    /**
     * Get an Image by name.
     * 
     * @param name      Image's name.
     */
    public getImage(name: string): Image;
    
    /**
     * Get an Volume by name.
     * 
     * @param name      Volume's name.
     */
    public getVolume(name: string): Volume;
    
    /**
     * Get a Service by ID or name.
     * 
     * @param id        Service's ID or name.
     */
    public getService(id: string): Service;
    
    /**
     * Get a Task by ID.
     * 
     * @param id        Task's ID.
     */
    public getTask(id: string): Task;
    
    /**
     * Get a Node by ID.
     * 
     * @param id        Node's ID.
     */
    public getNode(id: string): Node;
    
    /**
     * Get a Network by ID or name.
     * 
     * @param id        Network's ID or name.
     */
    public getNetwork(id: string): Network;
    
    /**
     * Get a Exec by ID.
     * 
     * @param id        Exec's ID.
     */
    public getExec(id: string): Exec;
    
    /**
     * List containers.
     * 
     * @param callback  Callback which will be called when call ends.
     */
    public listContainers(callback: Callback<Container.ContainerListItem[]>): void;
    /**
     * List containers.
     * 
     * @param opts      Containers list options.
     * @param callback  Callback which will be called when call ends.
     */
    public listContainers(opts: Docker.ContainerListOptions, callback: Callback<Container.ContainerListItem[]>): void;

    /**
     * List images.
     * 
     * @param callback  Callback which will be called when call ends.
     */
    public listImages(callback: Callback<Image.ImageResult[]>): void;
    /**
     * List images.
     * 
     * @param opts      Images list options.
     * @param callback  Callback which will be called when call ends.
     */
    public listImages(opts: Docker.ImageListOptions, callback: Callback<Image.ImageResult[]>): void;

    /**
     * List services.
     * 
     * @param callback  Callback which will be called when call ends.
     */
    public listServices(callback: Callback<Service.ServiceResult[]>): void;
    /**
     * List services.
     * 
     * @param opts      Service list options.
     * @param callback  Callback which will be called when call ends.
     */
    public listServices(opts: Docker.ServiceListOptions, callback: Callback<Service.ServiceResult[]>): void;

    /**
     * List nodes.
     * 
     * @param callback  Callback which will be called when call ends.
     */
    public listNodes(callback: Callback<Node.NodeResult[]>): void;

    /**
     * List tasks.
     * 
     * @param callback  Callback which will be called when call ends.
     */
    public listTasks(callback: Callback<Task.TaskResult[]>): void;
    /**
     * List tasks.
     * 
     * @param opts      Task list options.
     * @param callback  Callback which will be called when call ends.
     */
    public listTasks(opts: Docker.TaskListOptions, callback: Callback<Task.TaskResult[]>): void;

    /**
     * List volumes.
     * 
     * @param callback  Callback which will be called when call ends.
     */
    public listVolumes(callback: Callback<Volume.VolumeResult>): void;
    /**
     * List volumes.
     * 
     * @param opts      Volume list options.
     * @param callback  Callback which will be called when call ends.
     */
    public listVolumes(opts: Docker.VolumeListOptions, callback: Callback<Volume.VolumeResult>): void;

    /**
     * List networks.
     * 
     * @param callback  Callback which will be called when call ends.
     */
    public listNetworks(callback: Callback<Network.NetworkResult>): void;
    /**
     * List networks.
     * 
     * @param opts      Network list options.
     * @param callback  Callback which will be called when call ends.
     */
    public listNetworks(opts: Docker.NetworkListOptions, callback: Callback<Network.NetworkResult>): void;

    /**
     * Create a container.
     * 
     * @param opts      Container create options.
     * @param callback  Callback which will be called when call ends.
     */
    public createContainer(opts: Docker.CreateContainerOptions, callback: Callback<Container>);
    
    /**
     * Create a Volume.
     * 
     * @param opts      Volume create options.
     * @param callback  Callback which will be called when call ends.
     */
    public createVolume(opts: Docker.CreateVolumeOptions, callback: Callback<Volume>);
    
    /**
     * Create a service.
     * When using this endpoint to create a service using a private repository from the registry, the `X-Registry-Auth` header must be used to include a base64-encoded AuthConfig object.
     * Refer to the create an image section for more details.
     * 
     * @param opts      Service create options.
     * @param callback  Callback which will be called when call ends.
     */
    public createService(opts: Docker.CreateServiceOptions, callback: Callback<Service>);
    
    /**
     * Create a service.
     * When using this endpoint to create a service using a private repository from the registry, the `X-Registry-Auth` header must be used to include a base64-encoded AuthConfig object.
     * Refer to the create an image section for more details.
     * 
     * @param auth      Authentication options.
     * @param opts      Service create options.
     * @param callback  Callback which will be called when call ends.
     */
    public createService(auth: AuthConfig, opts: Docker.CreateServiceOptions, callback: Callback<Service>);

    /**
     * Create a Network.
     * 
     * @param opts      Network create options.
     * @param callback  Callback which will be called when call ends.
     */
    public createNetwork(opts: Docker.CreateNetworkOptions, callback: Callback<Network>);
    
    /**
     * Display system-wide information.
     * 
     * @param callback  Callback which will be called when call ends.
     */
    public info(callback: Callback<Docker.InfoResult>): void;

    /**
     * Show the docker version information.
     * 
     * @param callback  Callback which will be called when call ends.
     */
    public version(callback: Callback<Docker.VersionResult>): void;

    /**
     * Ping the docker server
     * 
     * @param callback  Callback which will be called when call ends.
     */
    public ping(callback: Callback<"OK">): void;

    /**
     * Monitor Docker’s events.
     * 
     * @param callback  Callback which will be called when call ends.
     */
    public getEvents(callback: Callback<Docker.EventResult[]>): void;
    /**
     * Monitor Docker’s events.
     * 
     * @param opts      Docker's events list options.
     * @param callback  Callback which will be called when call ends.
     */
    public getEvents(opts: Docker.GetEventOptions, callback: Callback<Docker.EventResult[]>): void;

    /**
     * Pull is a wrapper around parsing out the tag from the image.
     * (which create image cannot do but run can for whatever reasons) and create image overloading.
     * 
     * @param repoTag   The repository tag.
     * @param callback  Callback which will be called when call ends.
     * @param [auth]    Authentication configuration for this pull.
     */
    public pull(repoTag: string, callback: Callback<Readable>, auth?: AuthConfig): void;
    /**
     * Pull is a wrapper around parsing out the tag from the image.
     * (which create image cannot do but run can for whatever reasons) and create image overloading.
     * 
     * @param repoTag   The repository tag.
     * @param opts      Docker pull options.
     * @param callback  Callback which will be called when call ends.
     * @param [auth]    Authentication configuration for this pull.
     */
    public pull(repoTag: string, opts: Docker.CreateImageOptions, callback: Callback<Readable>, auth?: AuthConfig): void;

    /**
     * Like run command from Docker's CLI.
     * 
     * @param image         Image name to be used.
     * @param cmd           Command to run in array format.
     * @param streamo       Output stream
     * @param callback  Callback which will be called when call ends.
     */
    public run(image: string, cmd: string[], streamo: NodeJS.WritableStream | NodeJS.WritableStream[], callback: (err: Error, data: Container.WaitResult, container: Container) => void): EventEmitter;
    
    /**
     * Like run command from Docker's CLI.
     * 
     * @param image         Image name to be used.
     * @param cmd           Command to run in array format.
     * @param streamo       Output stream
     * @param startOptions  Container start options.
     * @param callback  Callback which will be called when call ends.
     */
    public run(image: string, cmd: string[], streamo: NodeJS.WritableStream | NodeJS.WritableStream[], startOptions: Container.StartOptions, callback: (err: Error, data: Container.WaitResult, container: Container) => void): EventEmitter;
    
    /**
     * Like run command from Docker's CLI.
     * 
     * @param image         Image name to be used.
     * @param cmd           Command to run in array format.
     * @param streamo       Output stream
     * @param createOptions Container create options.
     * @param callback  Callback which will be called when call ends.
     */
    public run(image: string, cmd: string[], streamo: NodeJS.WritableStream | NodeJS.WritableStream[], createOptions: Docker.CreateContainerOptions, callback: (err: Error, data: Container.WaitResult, container: Container) => void): EventEmitter;
    
    /**
     * Like run command from Docker's CLI.
     * 
     * @param image         Image name to be used.
     * @param cmd           Command to run in array format.
     * @param streamo       Output stream
     * @param createOptions Container create options.
     * @param startOptions  Container start options.
     * @param callback  Callback which will be called when call ends.
     */
    public run(image: string, cmd: string[], streamo: NodeJS.WritableStream | NodeJS.WritableStream[], createOptions: Docker.CreateContainerOptions, startOptions: Container.StartOptions, callback: (err: Error, data: Container.WaitResult, container: Container) => void): EventEmitter;
    
    
    /**
     * Initialize a new swarm
     * 
     * @param opts      Swarm init options.
     * @param callback  Callback which will be called when call ends.
     */
    public swarmInit(opts: Docker.SwarmInitOptions, callback: Callback<string>): void;

    /**
     * Join an existing swarm.
     * 
     * @param opts      Swarm join options.
     * @param callback  Callback which will be called when call ends.
     */
    public swarmJoin(opts: Docker.SwarmJoinOptions, callback: Callback<void>): void;

    /**
     * Leave swarm.
     * 
     * @param callback  Callback which will be called when call ends.
     */
    public swarmLeave(callback: Callback<void>): void;
    /**
     * Leave swarm.
     * 
     * @param opts      Swarm leave options.
     * @param callback  Callback which will be called when call ends.
     */
    public swarmLeave(opts: Docker.SwarmLeaveOptions, callback: Callback<void>): void;

    /**
     * Update swarm.
     * 
     * @param opts      Swarm update options.
     * @param callback  Callback which will be called when call ends.
     */
    public swarmUpdate(opts: Docker.SwarmUpdateOptions, callback: Callback<void>): void;

    /**
     * Inspect swarm.
     * 
     * @param callback  Callback which will be called when call ends.
     */
    public swarmInspect(callback: Callback<Docker.SwarmDefinition>): void;


    /* EventEmitter Options */
    addListener(event: string, listener: Function): this;
    on(event: string, listener: Function): this;
    once(event: string, listener: Function): this;
    removeListener(event: string, listener: Function): this;
    removeAllListeners(event?: string): this;
    setMaxListeners(n: number): this;
    getMaxListeners(): number;
    listeners(event: string): Function[];
    emit(event: string, ...args: any[]): boolean;
    listenerCount(type: string): number;
}

namespace Docker {
    export interface SocketOptions {
        socketPath?: string;
    }
    export interface HostOptions {
        protocol?: string;
        host: string;
        port: number;
        ca?: Buffer;
        cert?: Buffer;
        key?: Buffer;
    }


    export interface CreateImageOptions {
        /**
         * Name of the image to pull.
         * The name may include a tag or digest.
         * This parameter may only be used when pulling an image.
         * The pull is cancelled if the HTTP connection is closed.
         */
        fromImage?: string;
        /**
         * Source to import.
         * The value may be a URL from which the image can be retrieved or - to read the image from the request body.
         * This parameter may only be used when importing an image.
         */
        fromSrc?: string;
        /**
         * Repository name given to an image when it is imported.
         * The repo may include a tag.
         * This parameter may only be used when importing an image.
         */
        repo?: string;
        /**
         * Tag or digest.
         * If empty when pulling an image, this causes all tags for the given image to be pulled.
         */
        tag?: string;
    }

    export interface LoadImageOptions {
        /** Boolean value, suppress progress details during load. Defaults to `0` / `false` if omitted. */
        quiet?: Boolean;
    }

    export interface BuildImageOptions {
        /** Path within the build context to the `Dockerfile`. This is ignored if remote is specified and points to an external `Dockerfile`. */
        dockerfile?: string;
        /** 
         * A name and optional tag to apply to the image in the `name:tag` format. 
         * If you omit the `tag` the default `latest` value is assumed.
         * You can provide one or more `t` parameters.
         */
        t?: string | string[];
        /**
         * A Git repository URI or HTTP/HTTPS context URI.
         * If the URI points to a single text file, the file’s contents are placed into a file called Dockerfile and the image is built from that file.
         * If the URI points to a tarball, the file is downloaded by the daemon and the contents therein used as the context for the build.
         * If the URI points to a tarball and the dockerfile parameter is also specified, there must be a file with the corresponding path inside the tarball.
         */
        remote?: string;
        /** Suppress verbose build output. */
        q?: Boolean;
        /** Do not use the cache when building the image. */
        nocache?: Boolean;
        /** Attempt to pull the image even if an older image exists locally. */
        pull?: Boolean;
        /** Remove intermediate containers after a successful build (default behavior). */
        rm?: Boolean;
        /** Always remove intermediate containers (includes `rm`). */
        forcerm?: Boolean;
        /** Set memory limit for build. */
        memory?: number;
        /** Total memory (memory + swap), `-1` to enable unlimited swap. */
        memswap?: number;
        /** CPU shares (relative weight). */
        cpushares?: number;
        /** CPUs in which to allow execution (e.g., `0-3`, `0,1`). */
        cpusetcpus?: string;
        /** The length of a CPU period in microseconds. */
        cpuperiod?: number;
        /** Microseconds of CPU time that the container can get in a CPU period. */
        cpuquota?: number;
        /**
         * JSON map of string pairs for build-time variables.
         * Users pass these values at build-time.
         * Docker uses the buildargs as the environment context for command(s) run via the Dockerfile’s RUN instruction or for variable expansion in other Dockerfile instructions.
         * This is not meant for passing secret values. Read more about the buildargs instruction
         */
        buildargs?: Dictionary<string>;
        /** Size of `/dev/shm` in bytes. The size must be greater than `0`. If omitted the system uses `64MB`. */
        shmsize?: number;
        /** JSON map of string pairs for labels to set on the image. */
        labels?: Dictionary<string>;
    }

    export interface SearchImagesOptions {
        /** Term to search. */
        term: string;
        /** Maximum returned search results. */
        limit?: number;
        /** 
         * A JSON encoded value of the filters (a `map[string][]string`) to process on the images list.
         * Available filters:
         *  - `stars=<number>`
         *  - `is-automated=(true|false)`
         *  - `is-official=(true|false)`
         */
        filters?: string | Dictionary<string>;
    }

    export interface SearchImagesResult {
        name: string;
        description: string;
        is_official: boolean;
        is_automated: boolean;
        star_count: number;
    }
    
    export interface CheckAuthOptions {
        username: string;
        password: string;
        serveraddress?: string;
        email?: string;
    }

    export interface CheckAuthResult {
        Status: string;
        IdentityToken: string;
    }

    export interface ContainerListOptions {
        /** Show all containers. Only running containers are shown by default (i.e., this defaults to `false`). */
        all?: Boolean;
        /** Show `limit` last created containers, include non-running ones. */
        limit?: number;
        /** Show only containers created since Id, include non-running ones. */
        since?: string;
        /** Show only containers created before Id, include non-running ones. */
        before?: string;
        /** Show the containers sizes. */
        size?: Boolean;
        /**
         * A JSON encoded value of the filters (a `map[string][]string`) to process on the containers list.
         * Available filters:
         *  - `exited=<int>`; – containers with exit code of `<int>`
         *  - `status=(created restarting running paused exited dead)`
         *  - `label=key` or `label="key=value"` of a container label
         *  - `isolation=(default process hyperv)` (Windows daemon only)
         *  - `ancestor`=(`<image-name>``[:<tag>]`, `<image id>` or `<image@digest>`)
         *  - `before`=(`<container id>` or `<container name>`)
         *  - `since`=(`<container id>` or `<container name>`)
         *  - `volume`=(`<volume name>` or `<mount point destination>`)
         *  - `network`=(`<network id>` or `<network name>`)
         */
        filters?: Filters;
    }

    export interface ImageListOptions {
        /** 1/True/true or 0/False/false, default `false`. */
        all?: Boolean;
        /** 
         * A JSON encoded value of the filters (a map[string][]string) to process on the images list.
         * Available filters:
         *  - `dangling=true`
         *  - `label=key` or `label="key=value"` of an image label
         *  - `before`=(`<image-name>[:<tag>]`, `<image id>` or `<image@digest>`)
         *  - `since`=(`<image-name>[:<tag>]`, `<image id>` or `<image@digest>`)
         */
        filters?: Filters;
        /** Only return images with the specified name. */
        filter?: string;
    }

    export interface ServiceListOptions {
        /**
         * a JSON encoded value of the filters (a `map[string][]string`) to process on the services list. 
         * Available filters:
         *  - `id=<node id>`
         *  - `name=<node name>`
         */
        filters?: Filters;
    }

    export interface NodeListOptions {
        /**
         * a JSON encoded value of the filters (a map[string][]string) to process on the nodes list.
         * Available filters:
         *  - `id=<node id>`
         *  - `name=<node name>`
         *  - `membership=(pending accepted rejected)`
         *  - `role=(worker	manager)`
         */
        filters?: Filters;
    }
    
    export interface TaskListOptions {
        /**
         * a JSON encoded value of the filters (a map[string][]string) to process on the nodes list.
         * Available filters:
         *  - `id=<task id>`
         *  - `name=<task name>`
         *  - `service=<service name>`
         *  - `node=<node id>`
         *  - `label=key` or `label="key=value"`
         *  - `desired-state=(running | shutdown | accepted)`
         */
        filters?: Filters;
    }
    
    export interface VolumeListOptions {
        /**
         * a JSON encoded value of the filters (a map[string][]string) to process on the nodes list.
         * Available filters:
         *  - `name=<volume-name>`: Matches all or part of a volume name.
         *  - `dangling=<boolean>`: When set to true (or 1), returns all volumes that are “dangling” (not in use by a container). 
         *                          When set to false (or 0), only volumes that are in use by one or more containers are returned.
         *  - `driver=<volume-driver-name>`: Matches all or part of a volume driver name.
         */
        filters?: Filters;
    }
    
    export interface NetworkListOptions {
        /**
         * a JSON encoded value of the filters (a map[string][]string) to process on the nodes list.
         * Available filters:
         *  - `driver=<driver-name>`: Matches a network’s driver.
         *  - `id=<network-id>`: Matches all or part of a network id.
         *  - `label=<key>` or `label=<key>=<value>` of a network label.
         *  - `name=<network-name>`: Matches all or part of a network name.
         *  - `type=["custom"|"builtin"]`: Filters networks by type. The custom keyword returns all user-defined networks.
         */
        filters?: Filters;
    }
    
    export interface CreateContainerOptions extends Container.ContainerConfig {
        name?: string;
        HostConfig?: Container.HostConfig;
        NetworkingConfig?: {
            EndpointsConfig: Dictionary<{
                IPAMConfig?: {
                    IPv4Address?: string;
                    IPv6Address?: string;
                    LinkLocalIPs?: string[];
                },
                Links?: string[];
                Aliases?: string[];
            }>;
        };
    }

    export interface CreateVolumeOptions {
        /** The new volume’s name. If not specified, Docker generates a name. */
        Name: string;
        /** Name of the volume driver to use. Defaults to `local` for the name. */
        Driver?: string;
        /** A mapping of driver options and values. These options are passed directly to the driver and are driver specific. */
        DriverOpts?: Dictionary<string>;
        /** Labels to set on the volume, specified as a map: `{"key":"value","key2":"value2"}`. */
        Labels?: Dictionary<string>;
    }
    
    export interface CreateServiceOptions extends Service.ServiceDefinition {
    }

    export interface CreateNetworkOptions extends Network.NetworkDefinition {
    }

    export interface InfoResult {
        ID: string;
        Architecture: string;
        ClusterStore: string;
        CgroupDriver: string;
        Containers: number;
        ContainersRunning: number;
        ContainersStopped: number;
        ContainersPaused: number;
        CpuCfsPeriod: boolean;
        CpuCfsQuota: boolean;
        Debug: boolean;
        DockerRootDir: string;
        Driver: string;
        DriverStatus: string[][];
        ExperimentalBuild: boolean;
        HttpProxy: string;
        HttpsProxy: string;
        IPv4Forwarding: boolean;
        Images: number;
        IndexServerAddress: string;
        InitPath: string;
        InitSha1: string;
        KernelMemory: boolean;
        KernelVersion: string;
        Labels: string[];
        MemTotal: number;
        MemoryLimit: boolean;
        NCPU: number;
        NEventsListener: number;
        NFd: number;
        NGoroutines: number;
        Name: string;
        NoProxy: string;
        OomKillDisable: boolean;
        OSType: string;
        OperatingSystem: string;
        Plugins: {
            Volume: string[];
            Network: string[];
        },
        RegistryConfig: {
            IndexConfigs: Dictionary<RegistryConfig>;
            InsecureRegistryCIDRs: string[];
        },
        "SecurityOptions": string[];
        "ServerVersion": string;
        "SwapLimit": boolean;
        "SystemStatus": string[][];
        "SystemTime": string;
    }

    export interface RegistryConfig {
        Name: string;
        Official: boolean;
        Secure: boolean;
        Mirrors: string[];
    }

    export interface VersionResult {
        Version: string;
        Os: string;
        KernelVersion: string;
        GoVersion: string;
        GitCommit: string;
        Arch: string;
        ApiVersion: string;
        BuildTime: string;
        "Experimental": boolean;
    }

    export interface GetEventOptions {
        /** Timestamp. Show all events created since timestamp and then stream. */
        since?: Timestamp;
        /** Timestamp. Show events created until given timestamp and stop streaming. */
        until?: Timestamp;
        /**
         * A json encoded value of the filters (a `map[string][]string`) to process on the event list.
         * Available filters:
         *  - `container=<string>`; – container to filter
         *  - `event=<string>`; – event to filter
         *  - `image=<string>`; – image to filter
         *  - `label=<string>`; – image and container label to filter
         *  - `type=<string>`; – either container or image or volume or network or daemon
         *  - `volume=<string>`; – volume to filter
         *  - `network=<string>`; – network to filter
         *  - `daemon=<string>`; – daemon name or id to filter
         */
        filters?: Dictionary<string>;
    }

    export interface EventResult {
        status?: string;
        id?: string;
        from?: string;
        Type: string;
        Action: string;
        Actor: {
            ID: string;
            Attributes: Dictionary<string>;
        };
        time: number;
        timeNano: number;
    }

    export interface SwarmInitOptions {
        /** 
         * Listen address used for inter-manager communication, as well as determining the networking interface used for the VXLAN Tunnel Endpoint (VTEP).
         * This can either be an address/port combination in the form `192.168.1.1:4567`, or an interface followed by a port number, like `eth0:4567`.
         * If the port number is omitted, the default swarm listening port is used.
         */
        ListenAddr?: string;
        /**
         * Externally reachable address advertised to other nodes.
         * This can either be an address/port combination in the form `192.168.1.1:4567`, or an interface followed by a port number, like `eth0:4567`.
         * If the port number is omitted, the port number from the listen address is used.
         * If `AdvertiseAddr` is not specified, it will be automatically detected when possible.
         */
        AdvertiseAddr?: string;
        /** Force creation of a new swarm. */
        ForceNewCluster?: Boolean;
        /** Configuration settings for the new swarm. */
        Spec?: SwarmSpec;
    }

    export interface SwarmSpec {
        /** Configuration settings for the orchestration aspects of the swarm. */
        Orchestration?: {
            /** Maximum number of tasks history stored. */
            TaskHistoryRetentionLimit?: number;
        };
        /** Raft related configuration. */
        Raft?: {
            /** Number of logs entries between snapshot. */
            SnapshotInterval?: number;
            /** Number of snapshots to keep beyond the current snapshot. */
            KeepOldSnapshots?: number;
            /** Number of log entries to keep around to sync up slow followers after a snapshot is created. */
            LogEntriesForSlowFollowers?: number;
            /** Amount of ticks (in seconds) between each heartbeat. */
            HeartbeatTick?: number;
            /** Amount of ticks (in seconds) needed without a leader to trigger a new election. */
            ElectionTick?: number;
        };
        /** Configuration settings for the task dispatcher. */
        Dispatcher?: {
            /** The delay for an agent to send a heartbeat to the dispatcher. */
            HeartbeatPeriod?: number;
        };
        /** Certificate authority configuration. */
        CAConfig?: {
            /** Automatic expiry for nodes certificates. */
            NodeCertExpiry?: Boolean;
            /** Configuration for forwarding signing requests to an external certificate authority. */
            ExternalCA?: {
                /** Protocol for communication with the external CA (currently only `cfssl` is supported). */
                Protocol?: string;
                /** URL where certificate signing requests should be sent. */
                URL?: string;
                /** An object with key/value pairs that are interpreted as protocol-specific options for the external CA driver. */
                Options?: Dictionary<string>;
            };
        };
    }

    export interface SwarmJoinOptions {
        /** Listen address used for inter-manager communication if the node gets promoted to manager, as well as determining the networking interface used for the VXLAN Tunnel Endpoint (VTEP). */
        ListenAddr: string;
        /**
         * Externally reachable address advertised to other nodes.
         * This can either be an address/port combination in the form `192.168.1.1:4567`, or an interface followed by a port number, like `eth0:4567`.
         * If the port number is omitted, the port number from the listen address is used.
         * If `AdvertiseAddr` is not specified, it will be automatically detected when possible.
         */
        AdvertiseAddr?: string;
        /** Address of any manager node already participating in the swarm. */
        RemoteAddrs: string[];
        /** Secret token for joining this swarm. */
        JoinToken: string;
    }

    export interface SwarmLeaveOptions {
        /** Force leave swarm, even if this is the last manager or that it will break the cluster. */
        force?: Boolean;
    }

    export interface SwarmUpdateOptions extends SwarmSpec {
        /** Name of the Swarm. */
        Name: string;
        /** Tokens that can be used by other nodes to join the swarm. */
        JoinTokens?: SwarmJoinTokens;

        /** The version number of the swarm object being updated. This is required to avoid conflicting writes. */
        version?: number;
        /**  Set to `true` (or `1`) to rotate the worker join token. */
        rotateWorkerToken?: Boolean;
        /** Set to `true` (or `1`) to rotate the manager join token. */
        rotateManagerToken?: Boolean;
    }

    export interface SwarmJoinTokens {
        /** Token to use for joining as a worker. */
        Worker?: string;
        /** Token to use for joining as a manager. */
        Manager?: string;
    }

    export interface SwarmDefinition {
        ID: string;
        Version: {
            Index: number;
        };
        CreatedAt: string;
        UpdatedAt: string;
        Spec: SwarmSpec & { Name: string; TaskDefaults: any };
        JoinTokens : SwarmJoinTokens;
    }
}

export = Docker;
}
declare module 'dockerode/lib/docker' {
import main = require('~dockerode/lib/docker');
export = main;
}
declare module 'dockerode' {
import main = require('~dockerode/lib/docker');
export = main;
}
